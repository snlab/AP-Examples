Maple Application Engine
========================

These are some notes on how to setup your system to run the Maple SDN
 application engine and to develop your own controllers using it.

These notes apply only to Debian Linux x86-64 platforms. Notes for other
platforms will be added soon.


PREREQUISITES
=============

There are three required components to use maple: Oracle's Java 7 JDK, Sqlite3,
and 32 bit compatibility libraries. The following sections describe how to
install them.

1. Oracle Java JDK 7

a. Install following the instructions here:

  http://www.wikihow.com/Install-Oracle-Java-JDK-on-Ubuntu-Linux

b. In addition, update the LD_LIBRARY_PATH so that the system can find the
libjvm.so shared library, which should be in
/usr/local/java/jdk1.7.0_51/jre/lib/amd64/server/. One way to accomplish this is
to do the following:

  sudo cp java-x86-64.conf /etc/ld.so.conf.d/
  sudo ldconfig

Note that you cannot simply export LD_LIBRARY_PATH from files such as
/etc/profile (see: https://help.ubuntu.com/community/EnvironmentVariables).


2. Sqlite3: On Ubuntu, you can do the following: 

  sudo apt-get install libsqlite3-dev


3. 32bit compatibility libraries

  sudo apt-get install ia32-libs

4. nodejs

  sudo add-apt-repository ppa:chris-lea/node.js
  sudo apt-get update
  sudo apt-get install nodejs

5. mongodb and cube. First install mongodb by following the instructions here:

   http://docs.mongodb.org/manual/tutorial/install-mongodb-on-ubuntu/

Then install cube by doing the following:

   git clone git@github.com:lmammino/cube-daemons.git
   cd cube-daemons
   sudo ./install.sh

INSTALLATION
============

1. Install license by doing the following:

  cd aksusbd-2.2.1-i386
  sudo ./dinst

2. Eclipse. You can work with maple entirely from with the Eclipse IDE
[4]. Please see the section below on usage with Eclipse for more details. If you
only need to work from within Eclipse (recommended) then you can skip the
following step.

3. If you intend to invoke maple from the command line (as opposed to entirely
from within Eclipse), then it may be convenient (though not absolutely
necessary) to copy some files to a standard directory and to set up some
environment variables.

First copy this (the distribution) directory to '~/.maple', where '~' stands for
your home directory. In other words, run the following command from just above
the distribution directory:

  cp -r maple-<RELEASE>-linux-x64 ~/.maple

3. Add ~/.maple/bin to the $PATH environment variable, so that the 'maple'
executable can be run easily. For example, you can add the following lines to
.bashrc (or .profile, .bash_profile, etc. as needed) file:

  export PATH=$PATH:$HOME/.maple/lib

To test whether the installation was successful, you can run

  maple --help

This command should list various command line options for maple. If you don't
see the options, the installation is probably broken.



USAGE
=====

The workflow for implementing an OpenFlow network controller with Maple is as follows:

  1. Write your packet forwarding logic as a Java class, using the API defined
  in the included maple.jar 

  2. Compile the Java classes needed written in step 1 above.

  3. Run the "maple" executable, specifying the name of your class (from Step 1)
  and the location of the compiled class files (from Step 2).

We illustrate this workflow with an example. The "examplessrc" folder contains a
collection of Maple policies and related Java code. In particular, each of the
top-level files in this folder is a Maple algorithmic policy, i.e. an example
packet processing function from Step 1 above. The examples included are:

  1. Broadcast.java: forwards packets from each source along a minimum spanning
  tree from the source.

  2. SP.java: forwards packets from each source along the minimum spanning tree,
  unless the location of the destination host is known. In this case, packets
  are forwarded along the shortest path from sender to receiver. Also, tcp port
  22 packets are dropped.

  3. SPBadHosts.java: similar to SP.java, but ensures that packets are dropped
  if either the sender or receiver is in the "bad host" set. The bad host set
  can be modified at runtime via commands sent to Maple's HTTP REST API (see
  below).

  4. Null.java: drops all packets

  5. ECMP.java: uses ECMP routing from the maple.routing.Digraph class.

  6. SPVACL.java: applies (non-stateful) firewall policy to packets and
  otherwise forwards packets using the same method as SP.java.

  7. HashServerLoadBalancer.java: balances TCP flows to a virtual IP (VIP) 
  across a set of actual servers.

  8. SPCounter.java: Demonstrates the use of flow-level counters and
  asynchronous sending of packets (i.e. not driven by incoming
  packets).

To illustrate the process, consider Broadcast.java. The Broadcast class derives
from MapleFunction, which is a base class provided by the installed maple.jar,
which all Maple policies must derive from. This class overrides the onPacket()
method of the base class, that defines how packets are handled. Note that this
function MUST be overriden by the policy. This function returns a route via an
object of class Route. In this instance, Broadcast.onPacket uses multicast() to
construct a Route sending packets along a tree rooted at the sender. The
function makes use of built-in state components provided by MapleFunction, such
as switches(), links(), edgePorts() and hostLocation(), as well as packet
attributes, such as Packet.ethSrc(). The function makes use of the
maple.routing.Digraph class to perform routing computations, such as computing a
minimum spanning tree with the minSpanningTree() method. This class (and related
classes) is included under the examplessrc directory.

You can learn more about the built-in state components of MapleFunction, the
packet access API, the Route constructors and more by reading the javadocs
located in the "javadocs" folder.

If you are using Maple with the Eclipse IDE, then you the Broadcast class (and
all other classes) are compiled automatically. You can then run the Broadcast
maple application using the provided launch configuration, as discussed in the
section on Eclipse below.

If you are not using Eclipse, we can build and run the code as follows. Firstly,
we assume you have followed the instructions in the INSTALL section regarding
the non-Eclipse setup (step 3).  The distribution includes an ant build file
(build.xml), which can be invoked by running "ant" in the distribution (you may
need to install ant on your platform). The build script references the jars
located in ~/.maple/jars created during the installation above. The compilation
generates Java class files and places them in the "classes" folder.

Finally, we can run the Broadcast controller, by invoking the following command,
where the current working directory of the invoking process (i.e. the shell) is
in the distribution directory:

  maple -u classes Broadcast

If you enter the classes directory, then you can run without the -u
argument. I.e. you can run

  maple Broadcast

Once maple is running (either using Eclipse or the command line), maple will
start an OpenFlow 1.0 server waiting for switches to connect with it. The
program will be listening on the default OpenFlow port (6633).  You can also
specify various parameters, such as the port to listen on, with command line
arguments to maple. Run maple --help to get information on configurable options
and defaults.

At this point, you can test the running controller using real or virtual
OpenFlow switches. One popular and easy way to experiment is to use Mininet [3]
to run any number of virtual (OVS) switches in any desired topology. If you run
maple on your host with mininet running in a virtual machine on the host, you
can connect the mininet switches to the maple controller by providing a command
line argument like this:

  mn --controller=remote,ip=192.168.56.1:6633 ... (your other arguments) ...

This will work if your host machine (the one running maple) has IP 192.168.56.1.s


ECLIPSE Java Development Environment
====================================

You can also use an Integrated Development Environment (IDE), such as Eclipse
[4], to write Maple applications. This distribution includes a sample Eclipse
Java project that allows you to easily edit and run the sample programs
mentioned above, benefitting from Eclipse's auto-completion and javadoc
features.

To open the sample Eclipse project, start Eclipse. Then choose the "File" menu
and then the "Import..." item in this menu. Once the import wizard opens, choose
"General" and then "Existing Projects into Workspace". Select the "Browse"
button next to the "Select root directory" dropdown. Navigate to the
distribution directory and then click "Open" button. Then click "Finish" in the
import wizard. Now you should have an Eclipse project with an "examplessrc"
directory containing all the Maple application examples. For example, you can
double-click on Broadcast.java to see this application's code.

This sample project provides a "launch configuration" that allows you to easily
launch a Maple application from within Eclipse. To do this, simply select
(highlight) the policy class in the package explorer menu (on the left hand side
usually). For example, you could select "Broadcast.java". Then go to "Run" menu
and choose "External Tools". Then select the launch configuration named "Run
maple" and then click the "Run" button. This should launch maple, providing
access to the Maple command line interpreter (CLI) (see next section for a
description of the CLI) in the "Console" pane from within Eclipse.

You should also be able to run the "Run maple" launch configuration from a
button on the "Toolbar".

If an error occurs when you run the launch configuration that says something
like: "Variable references empty selection: ${project_loc}", this simply means
that you have not selected a policy to run. Please click on a policy in the
project explorer (for example, Broadcast.java) and then launch again.


MAPLE CLI
========= 

The program provides a command-line interpreter (CLI), which allows you to view
aspects of the operational state. For example, you can type the following at the
maple CLI:

  maple> switches

to see a list of switches connected to the controller. Enter "help" or "?" to
see a listing of other available CLI commands.



HTTP REST API
=============

The maple executable provides an API following REST principles exposed via
HTTP, that allows external programs to access much of the same information
provided interactively at the maple CLI. By default, this server responds to
requests at port 3000 (this is configurable). For example, issuing GET
requests to the following addresses

http://localhost:3000/ports
http://localhost:3000/topology
http://localhost:3000/fib

will return information about the available ports of connected switches, the
discovered topology of the network, and the current forwarding table rules for
all switches in the network.  Requests can be made with a web browser, or with a
command-line tool, such as with curl, e.g.:

curl -H "Accept: application/json" -H "Content-Type: application/json" http://localhost:3000/ports

In addition the values for all flow counters created using the
MapleFunction.newCounter() method will be exposed on the HTTP REST API
at URL "flowcounters". The URL "flowcounter/NAME" gets the value of
just the counter named "NAME".

MAPLE WEB GUI
=============

The maple executable also provides a web-based GUI that provides a more visual
presentation of the information included in the CLI and the REST API. This can
be viewed by opening a browser to:

http://localhost:3000/maple/maple.html#/topology



MAPLE STATE
===========

Maple allows policies to use user-defined state components. There are currently
three types of state components: 

1. Variables: support reading and writing values.
2. Sets: support insert and delete operations and membership query.
3. Maps: support put and delete operations and lookup query.

A user policy can declare instances of these data types using the API provided
in the MapleFunction class. Then, the policy's packet processing function can
invoke operations (typically queries) on these instances. The key benefit of
using these data structures is that the Maple runtime system automatically
tracks the accesses and updates to these data structures so that any forwarding
configurations that depend on some state component's values are updated whenever
that state component is updated.

To illustrate this idea, consider the SPBadHosts.java example. It declares an
instance of a set of MAC addresses, with the folling member field definition:

  public MapleSet<Long> badHosts = newSet("BadHosts", Long.class);

This declaration declares that the set is a set containing objects of type
"Long". This uses Java Generics to provide a more type-safe API. In addition, it
defines "badHosts" to be a new, initially empty set, with name "BadHosts" and
with class "Long.class". The meaning of these parameters will be explained
below.

Then, the onPacket() function checks whether the sender or receiver is in this
set, and returns the nullRoute in this case. It does so with the following lines
from its onPacket() function:

  if (badHosts.contains(p.ethSrc()) || badHosts.contains(p.ethDst())) {
    return nullRoute;
  }

Here the contains() method is the set membership query.

Maple provides REST methods via its HTTP server to allow users to edit
variables, sets, and maps. In particular, the Maple server accepts state
commands POSTed to the "db" URL. The commands are represented as JSON
objects. The possible commands are:

{ "component": <NAME>, "method":"read" }
{ "component": <NAME>, "method":"write", "value": <VALUE> }
{ "component": <NAME>, "method":"read_set" }
{ "component": <NAME>, "method":"insert_set", "value": <VALUE> }
{ "component": <NAME>, "method":"delete_set", "value": <VALUE> }
{ "component": <NAME>, "method":"read_map" }
{ "component": <NAME>, "method":"insert_map", "key": <VALUE>, "value": <VALUE> }
{ "component": <NAME>, "method":"delete_map", "key": <VALUE> }

The <NAME> corresponds with the name given in the initialization of the
variable, set, or map (as in "BadHosts" above). The <VALUE> objects are
arbitrary JSON values, including objects, arrays, or primitives
(e.g. numbers). The format of <VALUE> objects must be a JSON representation of
the type specified in the state component's initialization. For example, we
specified Long.class as the type of the elements of the badHosts set above. In
this case, <VALUE> must be a JSON number that be parsed to Long. Maple uses the
Gson[1] library to convert between Java objects and JSON. Essentially, the JSON
must be formatted so that Gson can parse and serialize the type specified in the
component's initialization.

The Maple server's reply to requests to read information provides the requested
value as a JSON object.

For example, we can read the value of the BadHosts set with the following
command:

curl -H "Accept: application/json" -H "Content-Type: application/json" -X POST http://localhost:3000/db -d '{"component":"BadHosts","method":"read_set"}'

This will intially return a JSON-formatted empty list "[]".  We can insert mac
address 1 into the set, with the following command:

curl -H "Accept: application/json" -H "Content-Type: application/json" -X POST http://localhost:3000/db -d '{"component":"BadHosts","method":"insert_set","value":1}'

Performing a read of the set now, will return "[1]".  We can then delete mac
address 1 from the set, with the following command:

curl -H "Accept: application/json" -H "Content-Type: application/json" -X POST http://localhost:3000/db -d '{"component":"BadHosts","method":"delete_set","value":1}'

This same API can be used to implement GUIs for specific controllers. For
example, start a maple controller running SPBadHosts, and then navigate to 

http://localhost:3000/maple/maple.html#/badhosts

Now this editor can be used to edit the bad hosts set. The source code for the
Web GUI, such as this one can be found in ~/.maple/web. The GUI follows the
Model-View-Controller (MVC) pattern using the Angular[2] javascript web
framework. The starting points for reading the code are main.html and
leaf/js/maple.js. 

A second example can be seen in SPVACL.java. This policy applies a firewall
policy to each packet. The firewall policy is stored in a Maple Variable,
allowing it to be changed at runtime without re-starting the controller. The
variable stores a list of ACRule objects, where each ACRule object represents a
single line of a typical access control policy, having source and destination IP
prefixes, protocol type and source and destination port ranges. The current
state of the variable can be retrieved by external processes by executing:

curl -v -H "Accept: application/json" -H "Content-Type: application/json" -X POST http://localhost:3000/db -d '{"component":"acl","method":"read"}'

To update the firewall to consist of a single rule, we can use this:

curl -v -H "Accept: application/json" -H "Content-Type: application/json" -X POST http://localhost:3000/db -d '{"component":"acl","method":"write","value":[{"predicate":{"srcIp":0,"srcIpLen":"0","dstIp":0,"dstIpLen":"0","protocol":"TCP","srcPortBegin":0,"srcPortEnd":65535,"dstPortBegin":0,"dstPortEnd":65535},"action":"PERMIT"}]}'



MAPLE PERSISTENCE
=================

All state variable values are stored in a Sqlite3 database in the ~/.maple
directory (this location can be configured). This allows a maple controller to
be re-started without losing the state of the variables, which are often
administrative configuration parameters. 



CONTACT
=======

Please contact Andreas Voellmy (andreas.voellmy@gmail.com) with any questions or
problems.



REFERENCES
==========

[1] https://code.google.com/p/google-gson/
[2] http://angularjs.org
[3] Mininet. http://mininet.org.
[4] Eclipse. http://www.eclipse.org.